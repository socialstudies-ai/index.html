<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>13è·¯åœæ£‹ - è‡ªæˆ‘å°å¼ˆç‰ˆ</title>
    <style>
        body {
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            background-color: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }
        h1 { margin-bottom: 5px; }
        .controls {
            margin-bottom: 15px;
            background: #34495e;
            padding: 10px 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            margin: 0 5px;
            transition: 0.2s;
            font-weight: bold;
        }
        button:hover { opacity: 0.9; transform: translateY(-2px); }
        button:active { transform: translateY(0); }
        
        .btn-hint { background-color: #f1c40f; color: #2c3e50; }
        .btn-reset { background-color: #e74c3c; color: #fff; }

        #board-container {
            position: relative;
            box-shadow: 10px 10px 30px rgba(0,0,0,0.5);
            border-radius: 4px;
            overflow: hidden;
            border: 5px solid #5e4028; /* æœ¨æ¡†æ„Ÿ */
        }
        canvas {
            background-color: #DCB35C;
            cursor: pointer;
            display: block;
        }
        #status { 
            font-size: 1.5em; 
            margin-bottom: 15px; 
            color: #ecf0f1;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        .turn-indicator {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 10px;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>

    <h1>åœæ£‹ 13x13 (è‡ªæˆ‘å°å¼ˆ)</h1>
    
    <div id="status">
        <span class="turn-indicator" style="background-color: black;"></span>
        è¼ªåˆ°ï¼šé»‘æ£‹
    </div>

    <div class="controls">
        <button id="btnHint" class="btn-hint" onclick="showHint()">ğŸ’¡ çµ¦æˆ‘å»ºè­°</button>
        <button id="btnReset" class="btn-reset" onclick="resetGame()">ğŸ”„ é‡æ–°é–‹å§‹</button>
    </div>

    <div id="board-container">
        <canvas id="goBoard" width="540" height="540"></canvas>
    </div>

    <script>
        // --- éŠæˆ²åƒæ•¸ ---
        const BOARD_SIZE = 13;
        const CELL_SIZE = 40;
        const MARGIN = 30;
        const CANVAS_SIZE = MARGIN * 2 + CELL_SIZE * (BOARD_SIZE - 1);
        
        // --- DOM å…ƒç´  ---
        const canvas = document.getElementById('goBoard');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        
        // --- éŠæˆ²è®Šæ•¸ ---
        let board = []; 
        let currentPlayer = 1; // 1:é»‘, 2:ç™½
        let lastMove = null;
        let hintMove = null;

        canvas.width = CANVAS_SIZE;
        canvas.height = CANVAS_SIZE;

        // --- åˆå§‹åŒ–èˆ‡é‡ç½® ---
        function initBoard() {
            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            currentPlayer = 1;
            lastMove = null;
            hintMove = null;
            updateStatus();
            drawBoard();
        }

        function resetGame() {
            if(confirm("ç¢ºå®šè¦æ¸…ç©ºæ£‹ç›¤é‡æ–°é–‹å§‹å—ï¼Ÿ")) {
                initBoard();
            }
        }

        function updateStatus() {
            const colorName = currentPlayer === 1 ? "é»‘æ£‹" : "ç™½æ£‹";
            const colorCode = currentPlayer === 1 ? "black" : "white";
            statusEl.innerHTML = `
                <span class="turn-indicator" style="background-color: ${colorCode};"></span>
                è¼ªåˆ°ï¼š${colorName}
            `;
        }

        // --- ç¹ªåœ–é‚è¼¯ ---
        function drawBoard() {
            // èƒŒæ™¯
            ctx.fillStyle = "#DCB35C";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // æ ¼ç·š
            ctx.beginPath();
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            for (let i = 0; i < BOARD_SIZE; i++) {
                ctx.moveTo(MARGIN, MARGIN + i * CELL_SIZE);
                ctx.lineTo(MARGIN + (BOARD_SIZE - 1) * CELL_SIZE, MARGIN + i * CELL_SIZE);
                ctx.moveTo(MARGIN + i * CELL_SIZE, MARGIN);
                ctx.lineTo(MARGIN + i * CELL_SIZE, MARGIN + (BOARD_SIZE - 1) * CELL_SIZE);
            }
            ctx.stroke();

            // æ˜Ÿä½
            const stars = [3, 9, 6];
            ctx.fillStyle = "#000";
            stars.forEach(r => {
                stars.forEach(c => {
                    ctx.beginPath();
                    ctx.arc(MARGIN + c * CELL_SIZE, MARGIN + r * CELL_SIZE, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
            });

            // æ£‹å­
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0) {
                        drawStone(r, c, board[r][c]);
                    }
                }
            }

            // æœ€å¾Œä¸€æ‰‹çš„ç´…è‰²æ¨™è¨˜
            if (lastMove) {
                const x = MARGIN + lastMove.c * CELL_SIZE;
                const y = MARGIN + lastMove.r * CELL_SIZE;
                ctx.fillStyle = "red";
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            }

            // å»ºè­°æ¡†æ¡†
            if (hintMove) {
                const x = MARGIN + hintMove.c * CELL_SIZE;
                const y = MARGIN + hintMove.r * CELL_SIZE;
                ctx.strokeStyle = "#e74c3c";
                ctx.lineWidth = 3;
                ctx.strokeRect(x - 12, y - 12, 24, 24);
                hintMove = null; // ç•«ä¸€æ¬¡å°±æ¶ˆå¤±ï¼Œé¿å…å¹²æ“¾
            }
        }

        function drawStone(r, c, color) {
            const x = MARGIN + c * CELL_SIZE;
            const y = MARGIN + r * CELL_SIZE;
            ctx.beginPath();
            ctx.arc(x, y, CELL_SIZE / 2 - 2, 0, 2 * Math.PI);
            
            // ç°¡å–®ç«‹é«”æ„Ÿ
            const grad = ctx.createRadialGradient(x-5, y-5, 2, x, y, 15);
            if (color === 1) {
                grad.addColorStop(0, "#555");
                grad.addColorStop(1, "#000");
            } else {
                grad.addColorStop(0, "#fff");
                grad.addColorStop(1, "#ddd");
            }
            ctx.fillStyle = grad;
            ctx.fill();
            
            if (color === 2) {
                ctx.strokeStyle = "#ccc"; 
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // --- æ ¸å¿ƒè¦å‰‡ (æ°£èˆ‡æå­) ---
        function isValid(r, c) {
            return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;
        }

        function countLiberties(boardState, r, c) {
            const color = boardState[r][c];
            if (color === 0) return 0;
            const stack = [[r, c]];
            const visited = new Set([`${r},${c}`]);
            let liberties = 0;
            const countedLiberties = new Set();

            while (stack.length) {
                const [cr, cc] = stack.pop();
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr, dc]) => {
                    const nr = cr + dr, nc = cc + dc;
                    if (isValid(nr, nc)) {
                        if (boardState[nr][nc] === 0) {
                            if (!countedLiberties.has(`${nr},${nc}`)) {
                                liberties++;
                                countedLiberties.add(`${nr},${nc}`);
                            }
                        } else if (boardState[nr][nc] === color && !visited.has(`${nr},${nc}`)) {
                            visited.add(`${nr},${nc}`);
                            stack.push([nr, nc]);
                        }
                    }
                });
            }
            return liberties;
        }

        function getGroup(boardState, r, c) {
            const color = boardState[r][c];
            let group = [];
            let stack = [[r, c]];
            let visited = new Set([`${r},${c}`]);
            while(stack.length) {
                let [cr, cc] = stack.pop();
                group.push([cr, cc]);
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr, dc]) => {
                    let nr = cr+dr, nc = cc+dc;
                    if(isValid(nr, nc) && boardState[nr][nc] === color && !visited.has(`${nr},${nc}`)) {
                        visited.add(`${nr},${nc}`);
                        stack.push([nr, nc]);
                    }
                });
            }
            return group;
        }

        function tryMove(r, c, col) {
            // é€™è£¡æ¨¡æ“¬è½å­ï¼Œæª¢æŸ¥æ˜¯å¦åˆæ³•ï¼Œä¸¦å›å‚³çµæœ
            if (board[r][c] !== 0) return { success: false };

            let tempBoard = board.map(row => [...row]);
            tempBoard[r][c] = col;
            
            let capturedStones = [];
            const opponent = 3 - col;

            // æª¢æŸ¥å‘¨åœå°æ‰‹æ°£
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr, dc]) => {
                const nr = r + dr, nc = c + dc;
                if (isValid(nr, nc) && tempBoard[nr][nc] === opponent) {
                    if (countLiberties(tempBoard, nr, nc) === 0) {
                        const group = getGroup(tempBoard, nr, nc);
                        group.forEach(([gr, gc]) => {
                            tempBoard[gr][gc] = 0;
                            capturedStones.push([gr, gc]);
                        });
                    }
                }
            });

            // ç¦æ­¢è‡ªæ®º (é™¤éå‰›å¥½æå­)
            if (capturedStones.length === 0 && countLiberties(tempBoard, r, c) === 0) {
                return { success: false, msg: "è‡ªæ®ºæ‰‹" };
            }

            return { success: true, newBoard: tempBoard, captured: capturedStones.length };
        }

        // --- é»æ“Šäº‹ä»¶ ---
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const c = Math.round((x - MARGIN) / CELL_SIZE);
            const r = Math.round((y - MARGIN) / CELL_SIZE);

            if (isValid(r, c)) {
                const result = tryMove(r, c, currentPlayer);
                if (result.success) {
                    board = result.newBoard;
                    lastMove = {r, c};
                    // æ’­æ”¾è½å­éŸ³æ•ˆæ„Ÿ (å¯é¸)
                    
                    // æ›äºº
                    currentPlayer = 3 - currentPlayer;
                    updateStatus();
                    drawBoard();
                } else {
                    console.log("ç„¡æ•ˆçš„ä¸€æ‰‹:", result.msg);
                }
            }
        });

        // --- AI å»ºè­°é‚è¼¯ ---
        function showHint() {
            const bestMove = getBestMove(currentPlayer);
            if (bestMove) {
                hintMove = bestMove;
                drawBoard();
                alert(`è»å¸«å»ºè­° ${currentPlayer===1?"é»‘":"ç™½"}æ£‹ï¼š\nä¸‹åœ¨ç¬¬ ${bestMove.r+1} åˆ—ï¼Œç¬¬ ${bestMove.c+1} è¡Œ`);
            }
        }

        function getBestMove(color) {
            let bestScore = -99999;
            let bestMoves = [];

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === 0) {
                        // ç°¡å–®è©•ä¼°å‡½æ•¸
                        let score = 0;
                        const result = tryMove(r, c, color);
                        
                        if (result.success) {
                            // 1. æå­åŠ åˆ†
                            score += result.captured * 100;
                            
                            // 2. è‡ªå·±çš„æ°£ (é¿å…è¢«å«åƒ)
                            const libs = countLiberties(result.newBoard, r, c);
                            if (libs === 1) score -= 50; 
                            score += libs * 5;

                            // 3. ä½”æ“šä¸­å¿ƒ/é‡‘è§’éŠ€é‚Š
                            const dist = Math.abs(r - 6) + Math.abs(c - 6);
                            score += (10 - dist);
                            
                            // 4. éš¨æ©Ÿæ“¾å‹•
                            score += Math.random() * 5;

                            if (score > bestScore) {
                                bestScore = score;
                                bestMoves = [{r, c}];
                            } else if (Math.abs(score - bestScore) < 2) {
                                bestMoves.push({r, c});
                            }
                        }
                    }
                }
            }
            if (bestMoves.length > 0) return bestMoves[Math.floor(Math.random() * bestMoves.length)];
            return null;
        }

        // å•Ÿå‹•
        initBoard();

    </script>
</body>
</html>